<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skill Fantasy</title>
    <style>
      table {
        border-collapse: collapse;
        font-family: monospace;
      }
      td, th {
        width: 0.7rem;
        height: 0.7rem;
        font-size: 0.4rem;
        font-family: "Courier New", Courier, monospace;
        text-align: center;
        vertical-align: middle;
        /*border: 1px solid black;*/
      }
      .player {
        background-color: red;
        color: yellow;
      }
      .grass {
        background-color: green;
        color: yellow;
      }
      .wall {
        background-color: darkgray;
        color: gray;
      }
      .ruler {
        background-color: lightgray;
      }

      .zmb {
        background-color: lime;
        color: cyan;
      }
      .pig {
        background-color: pink;
        color: white;
      }

      #world {
        float: left;
      }

      #controls {
        float: right;
      }
    </style>
  </head>
  <body>
    <table id="world"></table>
    <div id="controls">
      <h3>Controls</h3>
      <button id="move-left">Move Left</button>
      <button id="move-down">Move Down</button>
      <button id="move-up">Move Up</button>
      <button id="move-right">Move Right</button>
      <br />
      <button id="switch-mode">Switch to unplace mode</button>
    </div>
    <script type="text/javascript">
      const WORLD_WIDTH = 64
      const WORLD_HEIGHT = 64
      const TILE_GRASS = 0
      const VIEW_WIDTH = 25
      const VIEW_HEIGHT = 25
      const HALF_VIEW_WIDTH = Math.round(VIEW_WIDTH/2)
      const HALF_VIEW_HEIGHT = Math.round(VIEW_HEIGHT/2)

      class POINT {
        constructor(x, y) {
          this.x = x
          this.y = y
        }
      }

      POINT.eq = (a, b) => a.x == b.x && a.y == b.y;

      class PLAYER {
        constructor(x, y, health) {
          this.position = new POINT(x, y)
          this.health = health
          this.mode = "place";
        }

        Move(dx, dy) {
          this.position.x = Math.min(WORLD_WIDTH-1, Math.max(0, this.position.x + dx))
          this.position.y = Math.min(WORLD_HEIGHT-1, Math.max(0, this.position.y + dy))
        }

        switchMode() {
          let old = this.mode;
          this.mode = this.mode == "place"
            ? "unplace"
            : "place";
          document.getElementById("switch-mode").innerText = `Switch to ${old} mode`;
        }
      }

      let seed = 0x1234567;

      function rng32() {
        seed ^= seed << 13;
        seed ^= seed >> 17;
        seed ^= seed << 5;
        return seed;
      }

      function hsh32(x, y) {
        let result = 0x1234567;
        result = result * 631 + x;
        result = result * 631 + y;
        result ^= result << 13;
        result ^= result >> 17;
        result ^= result << 5;
        return result;
      }

      function lerp(a, b, t) {
        return (1.0-t) * a + t * b;
      }

      function fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
      }

      function val8(x, y) {
        let ix = Math.floor(x);
        let iy = Math.floor(y);
        let fx = x - ix;
        let fy = y - iy;
        let u = fade(fx);
        let v = fade(fy);
        let h00 = hsh32(ix, iy)&255;
        let h10 = hsh32(ix+1, iy)&255;
        let h01 = hsh32(ix, iy+1)&255;
        let h11 = hsh32(ix+1, iy+1)&255;
        return lerp(lerp(h00, h10, u), lerp(h01, h11, u), v);
      }

      function val8o(x, y) {
        let xa = x;
        let ya = y;
        let a = 1.0;
        let div = 0;
        let fin = 0;
        for (let o = 0; o < 3; o++) {
          fin += (val8(xa, ya)*2-255) * a;
          div += a;
          xa *= 2;
          ya *= 2;
          a *= 0.58;
        }
        fin = fin * 0.5 + 0.5;
        return Math.floor(fin / div);
      }

      function hsh3d32(x, y, z) {
        let result = 0x1234567;
        result = result * 631 + x;
        result = result * 631 + y;
        result = result * 631 + z;
        result ^= result << 13;
        result ^= result >> 17;
        result ^= result << 5;
        return result;
      }

      function val3d8(x, y, z) {
        let ix = Math.floor(x);
        let iy = Math.floor(y);
        let iz = Math.floor(z);
        let fx = x - ix;
        let fy = y - iy;
        let fz = z - iz;
        let u = fade(fx);
        let v = fade(fy);
        let r = fade(fz);
        let h000 = hsh3d32(ix, iy, iz)&255;
        let h100 = hsh3d32(ix+1, iy, iz)&255;
        let h010 = hsh3d32(ix, iy+1, iz)&255;
        let h110 = hsh3d32(ix+1, iy+1, iz)&255;
        let h001 = hsh3d32(ix, iy, iz+1)&255;
        let h101 = hsh3d32(ix+1, iy, iz+1)&255;
        let h011 = hsh3d32(ix, iy+1, iz+1)&255;
        let h111 = hsh3d32(ix+1, iy+1, iz+1)&255;
        return lerp(
          lerp(
            lerp(h000, h100, u),
            lerp(h010, h110, u),
            v),
          lerp(
            lerp(h001, h101, u),
            lerp(h011, h111, u),
            v),
          r);
      }

      function val3d8o(x, y, z) {
        let xa = x;
        let ya = y;
        let za = z;
        let a = 1.0;
        let div = 0;
        let fin = 0;
        for (let o = 0; o < 3; o++) {
          fin += (val3d8(xa, ya, za)*2-255) * a;
          div += a;
          xa *= 2;
          ya *= 2;
          za *= 2;
          a *= 0.58;
        }
        fin = fin * 0.5 + 0.5;
        return Math.floor(fin / div);
      }

      rng32(); rng32();

      class WORLD {
        constructor() {
          this.tiles = new Array(WORLD_WIDTH * WORLD_HEIGHT).fill(TILE_GRASS)
          this.objs = [];
          this.player = new PLAYER(32, 32, 30)
          this.mobs = [...new Array(rng32()&15)].map(_ => ({
            x: rng32()&WORLD_WIDTH-1,
            y: rng32()&WORLD_HEIGHT-1,
            state: 'wander',
            chooser: (rng32()%2==0 ? 'zmb' : 'pig'),
          })).map(m => ({...m, sprite: m.chooser[0].toUpperCase()}));
        }

        tick() {
          this.mobs.forEach((m, idx, ms) => {
            const ctx = {m, idx, ms, w: this, p: this.player};
            choosers[m.chooser](ctx);
            states[m.state](ctx);
          });
        }

        mobAt(x, y) {
          return this.mobs.filter(m => POINT.eq(m, {x, y}))[0] || false;
        }

        objAt(x, y) {
          return this.objs.filter(o => POINT.eq(o, {x, y}))[0] || false;
        }

        place(pos) {
          if (!this.objAt(pos.x, pos.y) && !this.mobAt(pos.x, pos.y)) {
            this.objs = [...this.objs, pos];
          }
          world.tick();
          DrawWorld();
        }

        unplace(pos) {
          if (this.objAt(pos.x, pos.y)) {
            this.objs = this.objs.filter(o => !POINT.eq(o, pos));
          }
          world.tick();
          DrawWorld();
        }
      }

      const world = new WORLD()

      const states = {
        wander({m, idx, ms, w, p}) {
          switch (rng32()&3) {
          case 0: if (m.x!=0&&!w.objAt(m.x-1, m.y)) m.x--;
            break;
          case 1: if (m.x!=WORLD_WIDTH-1&&!w.objAt(m.x+1, m.y)) m.x++;
            break;
          case 2: if (m.y!=0&&!w.objAt(m.x, m.y-1)) m.y--;
            break;
          case 3: if (m.y!=WORLD_HEIGHT-1&&!w.objAt(m.x, m.y+1)) m.y++;
            break;
          }
        },
        follow({m, idx, ms, w, p}) {
          const distx = p.position.x-m.x, disty = p.position.y-m.y;
          if (m.x!=0&&distx<0&&!w.objAt(m.x-1, m.y)) m.x--;
          else if (m.x!=WORLD_WIDTH-1&&distx>0&&!w.objAt(m.x+1, m.y)) m.x++;
          else if (m.y!=0&&disty<0&&!w.objAt(m.x, m.y-1)) m.y--;
          else if (m.y!=WORLD_HEIGHT-1&&disty>0&&!w.objAt(m.x, m.y+1)) m.y++;
        },
        flee({m, idx, ms, w, p}) {
          const distx = p.position.x-m.x, disty = p.position.y-m.y;
          if (m.x!=WORLD_WIDTH-1&&distx<0&&!w.objAt(m.x+1, m.y)) m.x++;
          else if (m.x!=0&&distx>0&&!w.objAt(m.x-1, m.y)) m.x--;
          else if (m.y!=WORLD_HEIGHT-1&&disty<0&&!w.objAt(m.x, m.y+1)) m.y++;
          else if (m.y!=0&&disty>0&&!w.objAt(m.x, m.y-1)) m.y--;
        }
      };

      const choosers = {
        zmb({m, idx, ms, w, p}) {
          const distx = m.x - p.position.x;
          const disty = m.y - p.position.y;
          const dist = Math.abs(distx) + Math.abs(disty);
          if (dist < 6) {
            m.state = 'follow';
          } else {
            m.state = 'wander';
          }
        },
        pig({m, idx, ms, w, p}) {
          const distx = m.x - p.position.x;
          const disty = m.y - p.position.y;
          const dist = Math.abs(distx) + Math.abs(disty);
          if (dist < 6) {
            m.state = 'flee';
          } else {
            m.state = 'wander';
          }
        }
      };

      function DrawWorld() {
        const table = document.getElementById("world")
        table.innerHTML = ""

        const start_x = Math.max(0, Math.min(WORLD_WIDTH - VIEW_WIDTH - 1, world.player.position.x - HALF_VIEW_WIDTH))
        const start_y = Math.max(0, Math.min(WORLD_HEIGHT - VIEW_HEIGHT - 1, world.player.position.y - HALF_VIEW_HEIGHT))
        const end_x = Math.max(VIEW_WIDTH + 1, Math.min(WORLD_WIDTH, world.player.position.x + HALF_VIEW_WIDTH + 1))
        const end_y = Math.max(VIEW_HEIGHT + 1, Math.min(WORLD_HEIGHT, world.player.position.y + HALF_VIEW_HEIGHT + 1))
        const topRulerRow = document.createElement("tr")
        topRulerRow.appendChild(document.createElement("td"))
        for (let x = start_x; x < end_x; x++) {
          const cell = document.createElement("th")
          cell.className = "ruler"
          cell.innerText = x
          topRulerRow.appendChild(cell)
        }
        table.appendChild(topRulerRow)

        for (let y = start_y; y < end_y; y++) {
          const row = document.createElement("tr")
          const leftRulerCell = document.createElement("th")
          leftRulerCell.className = "ruler"
          leftRulerCell.innerText = y
          row.appendChild(leftRulerCell)
        for (let x = start_x; x < end_x; x++) {
          const cell = document.createElement("td")

          cell.onclick = () => { world[world.player.mode]({x, y}) };

          if (world.player.position.x == x && world.player.position.y == y) {
            cell.className = "player"
            cell.innerText = "@/"
          } else if (world.mobAt(x, y)) {
            const mob = world.mobAt(x, y);
            cell.className = mob.chooser;
            cell.innerText = mob.sprite;
          } else if (world.objAt(x, y)) {
            cell.className = "wall";
            cell.innerText = "##";
          } else if (world.tiles[y * WORLD_WIDTH + x] == TILE_GRASS) {
            cell.className = "grass"
            cell.innerText = ",,"
            const nx = x / 8.0 - 0.5;
            const ny = y / 8.0 - 0.5;
            const sampler = val8o(nx, ny)/8.0 - 0.5;
            const sample = (val3d8o(nx, ny, sampler)&127)+128;
            const i = sample;
            cell.style = `background-color: rgb(${i*0.5}, ${i*0.9}, ${i*0.6});`;
          }
          row.appendChild(cell)
        }
        table.appendChild(row)
      }
    }

    function ProcessKey(key) {
    switch (key) {
      case 'h':
        world.player.Move(-1, 0)
        break
      case 'j':
        world.player.Move(0, 1)
        break
      case 'k':
        world.player.Move(0, -1)
        break
      case 'l':
        world.player.Move(1, 0)
        break
      case ' ':
        world.player.switchMode();
    }

    world.tick();
    DrawWorld()
  }

  DrawWorld()

  document.addEventListener("keydown", event => ProcessKey(event.key))

  document.getElementById("move-left").addEventListener("click", () => ProcessKey('h'))
  document.getElementById("move-down").addEventListener("click", () => ProcessKey('j'))
document.getElementById("move-up").addEventListener("click", () => ProcessKey('k'))
document.getElementById("move-right").addEventListener("click", () => ProcessKey('l'))
document.getElementById("switch-mode").addEventListener("click", () => ProcessKey(' '))
</script>

  </body>
</html>
